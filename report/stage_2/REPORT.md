# 2021-highload-dht

Курсовой проект в рамках обучающей программы "[Технополис](https://polis.mail.ru)" по дисциплине [Высоконагруженные вычисления](https://polis.mail.ru/curriculum/program/discipline/1257/).

## Этап 2. Многопоточность

Произведем профилирование имеющегося на данный момент сервера без внесения
каких-либо изменений в исходный код, чтобы определить проблемные места.

Для тестирования с помощью wrk2 были подобраны оптимальные параметры для тестируемого железа.
Их можно увидеть в запускаемом скрипте [wrk2.sh](../../profiling/wrk2.sh).
Все тесты будут проводиться на одних и тех же параметрах.

### Первоначальный анализ

 - #### [wrk2 для PUT-запросов](./profiling/wrk2_before.txt)

Видно, что для 90% пользователей запросы происходят в нормальное время до `2ms`,
а дальше время отклика сервера начинает значительный рост `(> 74ms)`.

- #### [async-profiler CPU для PUT-запросов](./profiling/profiler_cpu_before.html)

- #### [async-profiler LOCK для PUT-запросов](./profiling/profiler_lock_before.html)

На графике `LOCK для PUT` видно, что значительную часть времени простоя потоки
проводят на методе `LsmDAO.upsert` при вставке элементов. Попробуем это исправить.

### Оптимизация метода `upsert`

Из метода `upsert` была удалена блокировка `synhronized`. Вместо неё реализована
неблокирующая запись в `MemTable`.

Проведем измерения снова:

 - #### [wrk2 для PUT-запросов](./profiling/wrk2_upsert_put.txt)
 - #### [async-profiler CPU для PUT-запросов](./profiling/profiler_cpu_upsert_put.html)
 - #### [async-profiler LOCK для PUT-запросов](./profiling/profiler_lock_upsert_put.html)

Из результатов профилирования `LOCK` видно, что удалось избавиться от lock'а `LsmDAO.upsert`.
Он стал занимать `0.13%` против предыдущих `29.11%` от общего времени блокировки.

Что касается результатов `wrk2`, тот тут мы тоже в выигрыше: 